<!DOCTYPE html>
<html>
<head>
    <!-- Load the Paper.js library -->
    <script type="text/javascript" src="./node_modules/paper/dist/paper-full.js"></script>
    <!-- Define inlined PaperScript associate it with myCanvas -->
    <script type="text/paperscript" canvas="myCanvas">
        function Piece(kind, color, pid) {
            var img_path = './imgs/' + kind + '-' + color + '.svg';
            return { kind: kind, color: color, img_path: img_path, icon: null, pid: pid };
        }

        function draw_board(l, s, from)
        {
            // board base
            <!-- var to = new Point(l, l) + from; -->
            var path = new Path.Rectangle(from, l);
            path.strokeColor = 'black';
            // squares
            for (var i = 0; i < 8; i++) {
                for (var j = 0; j < 8; j++) {
                    var s_from = new Point(s*i, s*j) + from;
                    var s_to = s_from + [s, s];
                    var sq = new Path.Rectangle(s_from, s_to);
                    sq.strokeColor = 'black';
                    // make checker pattern
                    sq.fillColor = ((i + j) % 2 == 1) ? '#cd8500' : '#ffd39b';
                };
            };
        };

        /** ///////////////////////////////////////////////////////////////////////////////////////
         * Piece class
         */ ///////////////////////////////////////////////////////////////////////////////////////
        function PieceClass(kind, color)
        {
            // Using var for variable declarations
            var self = this;
            
            self.kind = kind;
            self.color = color;
            self.idx = null;
            self.icon = null;
            self.img_path = './imgs/' + self.kind + '-' + self.color + '.svg';
        }

        PieceClass.prototype.set_idx = function(idx)
        {
            this.idx = idx;
        };

        PieceClass.prototype.init_icon = function(pos, from)
        {
            if (!this.icon) {
                // FIX: Using .bind(this) to correctly set the 'this' context inside the async callback
                // This is the ES5 way to handle asynchronous 'this' binding.
                paper.project.importSVG(this.img_path, function(item) {
                    item.position = pos + from;
                    item.scale(0.25);
                    this.icon = item;
                }.bind(this));
            }
        };

        PieceClass.prototype.move_icon = function(pos, from)
        {
            if (this.icon) {
                var new_pos = pos + from
                if (this.icon.position != new_pos) {
                    this.icon.position = new_pos;
                }
            } else {
                this.init_icon(pos, from);
            }
        };

        PieceClass.prototype.remove_icon = function()
        {
            if (this.icon) {
                this.icon.remove();
            } 
        };
        /** ///////////////////////////////////////////////////////////////////////////////////////
         */ ///////////////////////////////////////////////////////////////////////////////////////


        // I got FEN (aka new array of Pieces), i got old array of Pieces
        // could start with comparing the lengths of the new and old arrays:
        //     i)   if the len is the same -> silent move or castling or promotion
        //     ii)  if len(old) > len(new) -> capture or en-passante
        //     iii) if len(old) < len(new) -> error
        // for each item in the old array check if
        //     i)   new array has one just like that (kind, color, idx all the same)
        //     ii)  new array has one but in a different idx
        //     iii) new array doesnt have it

        function getSymmetricKeyDifference(mapA, mapB) {
            // NOTE: full LLM
            // 1. Create a lookup object to track key presence and source
            var lookup = {};
            
            // Get all OWN keys from mapA (safer than for...in)
            var keysA = Object.keys(mapA);
            var keysB = Object.keys(mapB);

            var i;
            var key;
            
            // 2. Process mapA: Set the source for all keys in mapA to 1
            for (i = 0; i < keysA.length; i++) {
                key = keysA[i];
                lookup[key] = 1; // Key is only in mapA so far
            }

            // 3. Process mapB: Compare keys against the lookup
            for (i = 0; i < keysB.length; i++) {
                key = keysB[i];
                
                if (lookup.hasOwnProperty(key)) {
                    // Key found in BOTH mapA (1) and mapB. Mark as shared (2).
                    lookup[key] = 2;
                } else {
                    // Key found ONLY in mapB. Mark as unique to mapB (3).
                    lookup[key] = 3;
                }
            }

            // 4. Build the final difference array
            var differenceKeys = [];

            // Iterate over the consolidated keys in the lookup object
            // We must use a for...in here, but we ensure safety with hasOwnProperty()
            // or, more robustly, iterate over the keys of the lookup object itself:
            var lookupKeys = Object.keys(lookup);

            for (i = 0; i < lookupKeys.length; i++) {
                key = lookupKeys[i];
                var status = lookup[key];

                // Symmetric Difference = keys unique to A (1) OR keys unique to B (3)
                if (status === 1 || status === 3) {
                    differenceKeys.push(key);
                }
            }

            return differenceKeys;
        }

        function partitionArray(array) {
            var partitioned = [];
            
            // The loop increments by 2 to process elements in pairs
            for (var i = 0; i < array.length; i += 2) {
                
                // 1. Create a sub-array to hold the pair
                var pair = [];
                
                // 2. Add the first element of the pair
                pair.push(array[i]);
                
                // 3. Check if a second element exists (i + 1)
                if (i + 1 < array.length) {
                    // Add the second element if the array is not exhausted
                    pair.push(array[i + 1]);
                }
                
                // 4. Add the completed pair (or single element) to the result array
                partitioned.push(pair);
            }
            
            return partitioned;
        }

        function get_board_diff(old_pieces, new_pieces)
        {
            if (old_pieces.length == new_pieces.length) {
                var hash_fn = function (p) {
                    return p.color + "_" + p.kind + "_" + p.idx;
                }
                var convert_key_pair_to_pieces = function (key_pair) {
                    console.assert(key_pair.length == 2);
                    var piece_from_str = key_pair[0];
                    var piece_to_str   = key_pair[1];

                    var piece_from_str_split = piece_from_str.split('_');
                    var piece_from_color = piece_from_str_split[0];
                    var piece_from_kind  = piece_from_str_split[1];
                    var piece_from_idx   = parseInt(piece_from_str_split[2], 10);

                    var piece_to_str_split = piece_to_str.split('_');
                    var piece_to_color = piece_to_str_split[0];
                    var piece_to_kind  = piece_to_str_split[1];
                    var piece_to_idx   = parseInt(piece_to_str_split[2], 10);

                    var piece_from = null;
                    for (var i=0; i<old_pieces.length; i++) {
                        var p = old_pieces[i];
                        if (p.color == piece_from_color && p.kind == piece_from_kind && p.idx == piece_from_idx) {
                            piece_from = p;
                            break;
                        }
                    }

                    var piece_to = null;
                    for (var i=0; i<new_pieces.length; i++) {
                        var p = new_pieces[i];
                        if (p.color == piece_to_color && p.kind == piece_to_kind && p.idx == piece_to_idx) {
                            piece_to = p;
                            break;
                        }
                    }
                    return [piece_from, piece_to];
                }

                // silent move or castling or promotion
                //   silent move
                //     1. figure out which piece moved
                var old_pieces_set = {};
                var new_pieces_set = {};
                
                for (var i = 0; i < old_pieces.length; i++) {
                    var p = old_pieces[i];
                    var key = hash_fn(p);
                    old_pieces_set[key] = p;
                }
                
                for (var j = 0; j < new_pieces.length; j++) {
                    var p = new_pieces[j];
                    var key = hash_fn(p);
                    new_pieces_set[key] = p;
                }
                var diff = getSymmetricKeyDifference(old_pieces_set, new_pieces_set);
                console.log(diff)

                if (diff.length == 2) {
                    // silent move
                    var moved = partitionArray(diff).map(convert_key_pair_to_pieces);
                    // FIXME: probably dont even need the PieceClass, only need idx
                    <!-- var idx_from = moved[0].idx; -->
                    <!-- var idx_to   = moved[1].idx; -->
                    <!-- for (var i = 0; i < old_pieces.length; i++) { -->
                    <!--     var p = old_pieces[i]; -->
                    <!--     var key = hash_fn(p); -->
                    <!--     old_pieces_set[key] = p; -->
                    <!-- } -->
                    return moved
                    
                } else if (diff.length == 4) {
                    // TODO castling
                } else {
                    // cant happen
                    throw new Error("Diff has invalid length!");
                }
                // TODO castling
                // TODO promotion
            } else if (old_pieces.length > new_pieces.length) {
                // capture or en-passante
            } else {
                // cant happen
                throw new Error("Pieces array can not increase in length!");
            }
        };

        function fen_to_pieces(fen)
        {
            var pieces = [];
            var i = 0;
            var fenPositions = fen.split(' ')[0];
            var fenRanks = fenPositions.split('/'); // 8 ranks
            var pieceId = 0;
            for (var fenRank = 0; fenRank < 8; fenRank++) {
                var file = 0;
                for (var j = 0; j < fenRanks[fenRank].length; j++) {
                    var char = fenRanks[fenRank][j];
                    // digit = empty squares
                    if (char >= '1' && char <= '8') {
                        file += parseInt(char, 10);
                    } else {
                        var color = char === char.toUpperCase() ? 'w' : 'b';
                        var kind = char.toLowerCase();
                        // convert FEN rank (8→1) to LERF index
                        var rank = 7 - fenRank;
                        var idx = rank * 8 + file;
                        <!-- pieces[idx] = new Piece(kind, color, pieceId++); -->
                        var new_piece = new PieceClass(kind, color);
                        new_piece.set_idx(idx);
                        pieces.push(new_piece);
                        i++;
                        file++;
                    }
                }
            }
            return pieces;
        }

        function draw_pieces(pieces, s, from)
        {
            for (var i = 0; i < pieces.length; i++) {
                if (pieces[i]) {
                    (function(p) {
                        var idx = p.idx;
                        var rank = Math.floor(idx / 8);
                        var file = idx % 8;
                        var pos = new Point(s*file + s/2, s*rank + s/2);
                        p.move_icon(pos, from);
                    })(pieces[i]);
                };
            };
        };

        <!-- function clear_all_icons(pieces) { -->
        <!--     for (var i = 0; i < 64; i++) { -->
        <!--         if (pieces[i]) { -->
        <!--             pieces[i].icon.remove(); -->
        <!--         }; -->
        <!--     }; -->
        <!-- }; -->

        // Constants and globals
        var origin = new Point(20, 20);
        var l = 256;
        var s = l / 8.0;
        draw_board(l, s, origin);
        <!-- clear_all_icons(pieces); -->
        CHESS_PIECES = fen_to_pieces("rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1")
        draw_pieces(CHESS_PIECES, s, origin);

        var highlight = new Path.Rectangle({
            point: [origin.x, origin.y],
            size: [s, s],
            strokeColor: 'green',
            strokeWidth: 3,
            fillColor: null,
            visible: false   // start hidden
        });

        function move_highlight(rank, file) {
            var s_from = new Point(s * file, s * rank) + origin;
            highlight.bounds = new Rectangle(s_from, new Size(s, s));
            highlight.visible = true;
        };

        var debugText = new PointText({
            point: [300, 50],
            fillColor: 'black',
            fontSize: 14,
            strokeBounds: new Path.Rectangle({
                point: [290, 30],
                size: [200, 70],
                strokeColor: 'black',
                fillColor: null,
            })
        });

        var tool = new Tool();

        tool.onMouseMove = function(event)
        {
            var p = event.point; // real canvas coords

            // Check if inside board
            if (p.x >= origin.x && p.y >= origin.y && p.x < 8*s + origin.x && p.y < 8*s + origin.y) {

                var file = Math.floor((p.x - origin.x) / s); // 0–7
                var rank = Math.floor((p.y - origin.y) / s); // 0–7
                var fileChar = String.fromCharCode('a'.charCodeAt(0) + file);
                var rankChar = 8 - rank;

                debugText.content = "mouse: " + p + "\n" + "square: " + fileChar + rankChar;
                
                var piece = null;
                var idx = 8 * rank + file;
                for (var i = 0; i < CHESS_PIECES.length; i++) {
                    if (CHESS_PIECES[i].idx == idx) {piece = CHESS_PIECES[i];}
                }
                var piece_txt = "\n" + "piece: " + (piece ? piece.color + " " + piece.kind : "");
                debugText.content += piece_txt;

            } else {
                debugText.content = "mouse: " + p;
            }
        };


        function move_icons_based_on_diff(pieces, diff)
        {
            for (var i = 0; i < diff.length; i++) {
                var diff_pair = diff[i];
                if (diff_pair.length == 2) {
                    // silent move
                    var idx_from = diff_pair[0].idx;
                    var idx_to   = diff_pair[1].idx;
                    for (var i = 0; i < pieces.length; i++) {
                        var p = pieces[i];
                        if (p.idx == idx_from) {
                            p.set_idx(idx_to);
                            var rank = Math.floor(idx_to / 8);
                            var file = idx_to % 8;
                            var pos = new Point(s*file + s/2, s*rank + s/2);
                            p.move_icon(pos, origin);
                        }
                    }
                } else {
                    // cant happen
                    throw new Error("Diff has invalid length!");
                }
            }
            
            return pieces;
        };

        // websocket connection to the chess engine
        var ws = new WebSocket("ws://localhost:8080")
        // Listen for messages
        ws.addEventListener("message", function(event) {
            console.log("Message from server ", event.data);
            var msgs = event.data.split('_');
            console.log("Messages: ", msgs);
            for (var i = 0; i < msgs.length; i++) {
                var msg_split = msgs[i].split(':');
                var msg_type = msg_split[0];
                var msg_body = msg_split[1];
                console.log("Msg  ", i, ": type=", msg_type, "; msg_body=", msg_body);
                if (msg_type == "s") {
                    // state updated
                    var serverFEN = msg_body.trim();
                    var new_pieces = fen_to_pieces(serverFEN);
                    var diff = get_board_diff(CHESS_PIECES, new_pieces);
                    CHESS_PIECES = move_icons_based_on_diff(CHESS_PIECES, diff)
                    draw_pieces(CHESS_PIECES, s, origin);
                    ws.send("lm");
                } else if (msg_type == "lm") {
                    // last move that was made
                    // TODO NEXT: move the icons based on the last move string instead of FEN diff
                    console.log("Last move: ", msg_body);
                }
            }

        });

        function idx_to_algebraic(idx) {
            var rank = Math.floor(idx / 8) + 1;
            var file = idx % 8;
            return String.fromCharCode(97 + file) + rank;
        };
        
        function move_piece(pieces, idx_from, idx_to) {
            if (idx_from == idx_to) {
                return;
            }
            // TODO use .filter of the array
            var piece = null;
            for (var i = 0; i < pieces.length; i++) {
                if (pieces[i].idx == idx_from) {piece = pieces[i];}
            }
            console.assert(piece);
            var algebraic_from = idx_to_algebraic(idx_from);
            var algebraic_to   = idx_to_algebraic(idx_to);
            var msg = "m " + piece.color + " " + piece.kind + " " + algebraic_from + algebraic_to;
            ws.send(msg);
            return;
        };

        <!-- function capture_piece(pieces, idx_from, idx_to) { -->
        <!--     if (idx_from == idx_to) { -->
        <!--         return pieces; -->
        <!--     } -->
        <!--     // FIXME: record in the list of captured pieces -->
        <!--     var captured_piece = pieces[idx_to]; -->
        <!--     captured_piece.icon.remove(); -->
        <!--     pieces[idx_to] = null; -->
        <!--     return move_piece(pieces, idx_from, idx_to); -->
        <!-- }; -->

        var turn = 'w';
        var piece_selected = null;
        tool.onMouseDown = function(event) {
            var p = event.point; // real canvas coords
            if (p.x >= origin.x && p.y >= origin.y && p.x < 8*s + origin.x && p.y < 8*s + origin.y) {
                var file = Math.floor((p.x - origin.x) / s); // 0–7
                var rank = Math.floor((p.y - origin.y) / s); // 0–7
                // this click event is to put the piece down on a new square (ie move piece)
                if (piece_selected) {
                    // about to move or capture
                    var piece = null;
                    var idx = 8 * rank + file;
                    for (var i = 0; i < CHESS_PIECES.length; i++) {
                        if (CHESS_PIECES[i].idx == idx) {piece = CHESS_PIECES[i];}
                    }
                    if (piece) {
                        if (piece.color != piece_selected.color) {
                            <!-- // capture -->
                            <!-- for (var i = 0; i < 64; i++) { -->
                            <!--     if (CHESS_PIECES[i] && (CHESS_PIECES[i].pid == piece_selected.pid)) { -->
                            <!--         pieces = capture_piece(pieces, i, 8 * rank + file); -->
                            <!--         break; -->
                            <!--     } -->
                            <!-- } -->
                        };
                    } else {
                        // FIXME: surely there is a better way since we already have access to
                        // piece_selected
                        move_piece(CHESS_PIECES, piece_selected.idx, 8 * rank + file);
                    };
                    var pos = new Point(s*file + s/2, s*rank + s/2);
                    <!-- piece_selected.icon.position = pos + origin; -->
                    piece_selected.move_icon(pos, origin);
                    piece_selected = null;
                    highlight.visible = false;
                    return;
                } else {
                    // this click is to select a piece
                    // FIXME: this should remove the highlight and not move the piece if clicked on
                    // the empty square that is not a move or attack
                    var piece = null;
                    var idx = 8 * rank + file;
                    for (var i = 0; i < CHESS_PIECES.length; i++) {
                        if (CHESS_PIECES[i].idx == idx) {piece = CHESS_PIECES[i];}
                    }
                    if (piece && piece.color == turn) {
                        console.log(piece.color + " " + piece.kind);
                        move_highlight(rank, file);
                        piece_selected = piece;
                        draw_pieces(CHESS_PIECES, s, origin);
                    } else {
                        highlight.visible = false;
                    };
                }
            };
        };


    </script>

</head>
<body>
	<canvas id="myCanvas" width=1000 height=1000></canvas>
</body>
</html>
