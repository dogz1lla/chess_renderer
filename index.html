<!DOCTYPE html>
<html>
<head>
    <!-- Load the Paper.js library -->
    <script type="text/javascript" src="./node_modules/paper/dist/paper-full.js"></script>
    <!-- Define inlined PaperScript associate it with myCanvas -->
    <script type="text/paperscript" canvas="myCanvas">
        function draw_board(l, s, from)
        {
            // board base
            <!-- var to = new Point(l, l) + from; -->
            var path = new Path.Rectangle(from, l);
            path.strokeColor = 'black';
            // squares
            for (var i = 0; i < 8; i++) {
                for (var j = 0; j < 8; j++) {
                    var s_from = new Point(s*i, s*j) + from;
                    var s_to = s_from + [s, s];
                    var sq = new Path.Rectangle(s_from, s_to);
                    sq.strokeColor = 'black';
                    // make checker pattern
                    sq.fillColor = ((i + j) % 2 == 1) ? '#cd8500' : '#ffd39b';
                };
            };
        };

        /** ///////////////////////////////////////////////////////////////////////////////////////
         * Piece class
         */ ///////////////////////////////////////////////////////////////////////////////////////
        function PieceClass(kind, color)
        {
            // Using var for variable declarations
            var self = this;
            
            self.kind = kind;
            self.color = color;
            self.idx = null;
            self.icon = null;
            self.img_path = './imgs/' + self.kind + '-' + self.color + '.svg';
        }

        PieceClass.prototype.set_idx = function(idx)
        {
            this.idx = idx;
        };

        PieceClass.prototype.init_icon = function(pos, from)
        {
            if (!this.icon) {
                // FIX: Using .bind(this) to correctly set the 'this' context inside the async fn
                // This is the ES5 way to handle asynchronous 'this' binding.
                paper.project.importSVG(this.img_path, function(item) {
                    item.position = pos + from;
                    item.scale(0.25);
                    this.icon = item;
                }.bind(this));
            }
        };

        PieceClass.prototype.move_icon = function(pos, from)
        {
            if (this.icon) {
                var new_pos = pos + from
                if (this.icon.position != new_pos) {
                    this.icon.position = new_pos;
                }
            } else {
                this.init_icon(pos, from);
            }
        };

        PieceClass.prototype.remove_icon = function()
        {
            if (this.icon) {
                this.icon.remove();
            } 
        };
        /** ///////////////////////////////////////////////////////////////////////////////////////
         */ ///////////////////////////////////////////////////////////////////////////////////////

        function fen_to_pieces(fen)
        {
            var pieces = [];
            var i = 0;
            var fenPositions = fen.split(' ')[0];
            var fenRanks = fenPositions.split('/'); // 8 ranks
            var pieceId = 0;
            for (var fenRank = 0; fenRank < 8; fenRank++) {
                var file = 0;
                for (var j = 0; j < fenRanks[fenRank].length; j++) {
                    var char = fenRanks[fenRank][j];
                    // digit = empty squares
                    if (char >= '1' && char <= '8') {
                        file += parseInt(char, 10);
                    } else {
                        var color = char === char.toUpperCase() ? 'w' : 'b';
                        var kind = char.toLowerCase();
                        // convert FEN rank (8→1) to LERF index
                        var rank = 7 - fenRank;
                        var idx = rank * 8 + file;
                        <!-- pieces[idx] = new Piece(kind, color, pieceId++); -->
                        var new_piece = new PieceClass(kind, color);
                        new_piece.set_idx(idx);
                        pieces.push(new_piece);
                        i++;
                        file++;
                    }
                }
            }
            return pieces;
        }

        function draw_pieces(pieces, s, from)
        {
            for (var i = 0; i < pieces.length; i++) {
                if (pieces[i]) {
                    (function(p) {
                        var idx = p.idx;
                        var rank = Math.floor(idx / 8);
                        var file = idx % 8;
                        var pos = new Point(s*file + s/2, s*rank + s/2);
                        p.move_icon(pos, from);
                    })(pieces[i]);
                };
            };
        };

        // Constants and globals
        var origin = new Point(20, 20);
        var l = 256;
        var s = l / 8.0;
        var CHESS_PIECES = fen_to_pieces("rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1")
        var TURN = 'w';

        draw_board(l, s, origin);
        draw_pieces(CHESS_PIECES, s, origin);

        var highlight = new Path.Rectangle({
            point: [origin.x, origin.y],
            size: [s, s],
            strokeColor: 'green',
            strokeWidth: 3,
            fillColor: null,
            visible: false   // start hidden
        });

        function move_highlight(rank, file) {
            var s_from = new Point(s * file, s * rank) + origin;
            highlight.bounds = new Rectangle(s_from, new Size(s, s));
            highlight.visible = true;
        };

        var debugText = new PointText({
            point: [300, 50],
            fillColor: 'black',
            fontSize: 14,
            strokeBounds: new Path.Rectangle({
                point: [290, 30],
                size: [200, 70],
                strokeColor: 'black',
                fillColor: null,
            })
        });

        var tool = new Tool();

        tool.onMouseMove = function(event)
        {
            var p = event.point; // real canvas coords

            // Check if inside board
            if (p.x >= origin.x && p.y >= origin.y && p.x < 8*s + origin.x && p.y < 8*s + origin.y) {

                var file = Math.floor((p.x - origin.x) / s); // 0–7
                var rank = Math.floor((p.y - origin.y) / s); // 0–7
                var fileChar = String.fromCharCode('a'.charCodeAt(0) + file);
                var rankChar = 8 - rank;

                debugText.content = "mouse: " + p + "\n" + "square: " + fileChar + rankChar;
                
                var piece = null;
                var idx = 8 * rank + file;
                for (var i = 0; i < CHESS_PIECES.length; i++) {
                    if (CHESS_PIECES[i].idx == idx) {piece = CHESS_PIECES[i];}
                }
                var piece_txt = "\n" + "piece: " + (piece ? piece.color + " " + piece.kind : "");
                debugText.content += piece_txt;

            } else {
                debugText.content = "mouse: " + p;
            }
        };

        // websocket connection to the chess engine
        var ws = new WebSocket("ws://localhost:8080")
        // SERVER MESSAGE PARSING
        ws.addEventListener("message", function(event) {
            var msgs = event.data.split('_');
            console.log("Messages: ", msgs);
            for (var i = 0; i < msgs.length; i++) {
                var msg_split = msgs[i].split(':');
                var msg_type = msg_split[0];
                var msg_body = msg_split[1];
                console.log("Msg  ", i, ": type=", msg_type, "; msg_body=", msg_body);
                if (msg_type == "s") {
                    // state updated
                    <!-- var serverFEN = msg_body.trim(); -->
                    // ask for the last move string
                    ws.send("lm");
                } else if (msg_type == "lm") {
                    // last move that was made
                    move_piece_icon(CHESS_PIECES, msg_body);
                    // ask for the turn string
                    ws.send("t");
                } else if (msg_type == "t") {
                    // whose turn
                    TURN = msg_body;
                }
            }

        });

        function idx_to_algebraic(idx) {
            var rank = Math.floor(idx / 8) + 1;
            var file = idx % 8;
            return String.fromCharCode(97 + file) + rank;
        };

        function algebraic_to_idx(square) {
            // 1. Extract file (letter) and convert to 0-7
            // 'a'.charCodeAt(0) is 97
            var file = square.charCodeAt(0) - 97;

            // 2. Extract rank (number) and convert to 0-7 
            // We subtract 1 because your original function added 1
            var rank = parseInt(square.charAt(1)) - 1;

            // 3. Combine using the LERF formula
            return (rank * 8) + file;
        }

        function move_piece_icon(pieces, last_move_str) {
            var last_move_split = last_move_str.split(' ');
            var color = last_move_split[0];
            var kind  = last_move_split[1];
            var algebraic_move = last_move_split[2];

            var algebraic_from = algebraic_move.slice(0, 2);
            var algebraic_to   = algebraic_move.slice(2, 4);
            var idx_from = algebraic_to_idx(algebraic_from);
            var idx_to   = algebraic_to_idx(algebraic_to);

            for (var i = 0; i < pieces.length; i++) {
                var p = pieces[i];
                if (p.color == color && p.kind == kind && p.idx == idx_from) {
                    p.idx = idx_to;
                    break;
                }
            }
            draw_pieces(pieces, s, origin);
        }
        
        function move_piece(pieces, idx_from, idx_to) {
            if (idx_from == idx_to) {
                return;
            }
            // TODO use .filter of the array
            var piece = null;
            for (var i = 0; i < pieces.length; i++) {
                if (pieces[i].idx == idx_from) {piece = pieces[i];}
            }
            console.assert(piece);
            var algebraic_from = idx_to_algebraic(idx_from);
            var algebraic_to   = idx_to_algebraic(idx_to);
            var msg = "m " + piece.color + " " + piece.kind + " " + algebraic_from + algebraic_to;
            ws.send(msg);
            return;
        };

        // FIXME
        var piece_selected = null;
        tool.onMouseDown = function(event) {
            var p = event.point; // real canvas coords
            if (p.x >= origin.x && p.y >= origin.y && p.x < 8*s + origin.x && p.y < 8*s + origin.y) {
                var file = Math.floor((p.x - origin.x) / s); // 0–7
                var rank = Math.floor((p.y - origin.y) / s); // 0–7
                // this click event is to put the piece down on a new square (ie move piece)
                if (piece_selected) {
                    // about to move or capture
                    var piece = null;
                    var idx = 8 * rank + file;
                    for (var i = 0; i < CHESS_PIECES.length; i++) {
                        if (CHESS_PIECES[i].idx == idx) {piece = CHESS_PIECES[i];}
                    }
                    if (piece) {
                        if (piece.color != piece_selected.color) {
                            // the target square has a piece -> if different color then capture
                            // FIXME
                        };
                    } else {
                        // the target square has no piece -> move here
                        move_piece(CHESS_PIECES, piece_selected.idx, idx);
                    };
                    piece_selected = null;
                    highlight.visible = false;
                    return;
                } else {
                    // this click is to select a piece
                    // FIXME: this should remove the highlight and not move the piece if clicked on
                    // the empty square that is not a move or attack
                    var piece = null;
                    var idx = 8 * rank + file;
                    for (var i = 0; i < CHESS_PIECES.length; i++) {
                        if (CHESS_PIECES[i].idx == idx) {piece = CHESS_PIECES[i];}
                    }
                    if (piece && piece.color == TURN) {
                        console.log(piece.color + " " + piece.kind);
                        move_highlight(rank, file);
                        piece_selected = piece;
                    } else {
                        highlight.visible = false;
                    };
                }
            };
        };


    </script>

</head>
<body>
	<canvas id="myCanvas" width=1000 height=1000></canvas>
</body>
</html>
