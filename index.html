<!DOCTYPE html>
<html>
<head>
    <!-- Load the Paper.js library -->
    <script type="text/javascript" src="./node_modules/paper/dist/paper-full.js"></script>
    <!-- Define inlined PaperScript associate it with myCanvas -->
    <script type="text/paperscript" canvas="myCanvas">
        function Piece(kind, color, pid) {
            var img_path = './imgs/' + kind + '-' + color + '.svg';
            return { kind: kind, color: color, img_path: img_path, icon: null, pid: pid };
        }

        function init_positions(pieces) {
            pieces[0]  = new Piece('rook',    'w', 0);
            pieces[1]  = new Piece('knight',  'w', 1);
            pieces[2]  = new Piece('bishop',  'w', 2);
            pieces[3]  = new Piece('queen',   'w', 3);
            pieces[4]  = new Piece('king',    'w', 4);
            pieces[5]  = new Piece('bishop',  'w', 5);
            pieces[6]  = new Piece('knight',  'w', 6);
            pieces[7]  = new Piece('rook',    'w', 7);
            pieces[8]  = new Piece('pawn',    'w', 8);
            pieces[9]  = new Piece('pawn',    'w', 9);
            pieces[10] = new Piece('pawn',    'w', 10);
            pieces[11] = new Piece('pawn',    'w', 11);
            pieces[12] = new Piece('pawn',    'w', 12);
            pieces[13] = new Piece('pawn',    'w', 13);
            pieces[14] = new Piece('pawn',    'w', 14);
            pieces[15] = new Piece('pawn',    'w', 15);
            pieces[48] = new Piece('pawn',    'b', 16);
            pieces[49] = new Piece('pawn',    'b', 17);
            pieces[50] = new Piece('pawn',    'b', 18);
            pieces[51] = new Piece('pawn',    'b', 19);
            pieces[52] = new Piece('pawn',    'b', 21);
            pieces[53] = new Piece('pawn',    'b', 22);
            pieces[54] = new Piece('pawn',    'b', 23);
            pieces[55] = new Piece('pawn',    'b', 24);
            pieces[56]  = new Piece('rook',   'b', 25);
            pieces[57]  = new Piece('knight', 'b', 26);
            pieces[58]  = new Piece('bishop', 'b', 27);
            pieces[59]  = new Piece('queen',  'b', 28);
            pieces[60]  = new Piece('king',   'b', 29);
            pieces[61]  = new Piece('bishop', 'b', 30);
            pieces[62]  = new Piece('knight', 'b', 31);
            pieces[63]  = new Piece('rook',   'b', 32);
            return pieces;
        };

        function draw_pieces(pieces, s, from) {
            for (var i = 0; i < 64; i++) {
                if (pieces[i]) {
                    (function(p, i) {
                        var rank = Math.floor(i / 8);
                        var file = i % 8;
                        var pos = new Point(s*file + s/2, s*rank + s/2);
                        if (p.icon) {
                            p.icon.position = pos + from;
                        } else {
                            paper.project.importSVG(p.img_path, function(item) {
                                item.position = pos + from;
                                item.scale(0.25);
                                // save the reference to the svg object in the Piece object
                                p.icon = item;
                            });
                        };
                    })(pieces[i], i);
                };
            };
        };

        function move_piece(pieces, idx_from, idx_to) {
            if (idx_from == idx_to) {
                return pieces;
            }
            var piece = pieces[idx_from];
            pieces[idx_to] = piece;
            pieces[idx_from] = null;
            return pieces;
        };

        function capture_piece(pieces, idx_from, idx_to) {
            if (idx_from == idx_to) {
                return pieces;
            }
            // FIXME: record in the list of captured pieces
            var captured_piece = pieces[idx_to];
            captured_piece.icon.remove();
            pieces[idx_to] = null;
            return move_piece(pieces, idx_from, idx_to);
        };

        function draw_board(l, s, from) {
            // board base
            <!-- var to = new Point(l, l) + from; -->
            var path = new Path.Rectangle(from, l);
            path.strokeColor = 'black';
            // squares
            for (var i = 0; i < 8; i++) {
                for (var j = 0; j < 8; j++) {
                    var s_from = new Point(s*i, s*j) + from;
                    var s_to = s_from + [s, s];
                    var sq = new Path.Rectangle(s_from, s_to);
                    sq.strokeColor = 'black';
                    // make checker pattern
                    sq.fillColor = ((i + j) % 2 == 1) ? '#cd8500' : '#ffd39b';
                };
            };
        };

        // Constants and globals
        var origin = new Point(20, 20);
        var l = 256;
        var s = l / 8.0;
        draw_board(l, s, origin);
        var pieces = new Array(64);
        pieces = init_positions(pieces);
        draw_pieces(pieces, s, origin);

        var highlight = new Path.Rectangle({
            point: [origin.x, origin.y],
            size: [s, s],
            strokeColor: 'green',
            strokeWidth: 3,
            fillColor: null,
            visible: false   // start hidden
        });

        function move_highlight(rank, file) {
            var s_from = new Point(s * file, s * rank) + origin;
            highlight.bounds = new Rectangle(s_from, new Size(s, s));
            highlight.visible = true;
        };

        var debugText = new PointText({
            point: [300, 50],
            fillColor: 'black',
            fontSize: 14,
            strokeBounds: new Path.Rectangle({
                point: [290, 30],
                size: [200, 70],
                strokeColor: 'black',
                fillColor: null,
            })
        });

        var tool = new Tool();

        tool.onMouseMove = function(event) {
            var p = event.point; // real canvas coords

            // Check if inside board
            if (p.x >= origin.x && p.y >= origin.y && p.x < 8*s + origin.x && p.y < 8*s + origin.y) {

                var file = Math.floor((p.x - origin.x) / s); // 0–7
                var rank = Math.floor((p.y - origin.y) / s); // 0–7
                var fileChar = String.fromCharCode('a'.charCodeAt(0) + file);
                var rankChar = 8 - rank;

                debugText.content = "mouse: " + p + "\n" + "square: " + fileChar + rankChar;
                
                var piece = pieces[8 * rank + file];
                var piece_txt = "\n" + "piece: " + (piece ? piece.color + " " + piece.kind : "");
                debugText.content += piece_txt;

            } else {
                debugText.content = "mouse: " + p;
            }

            <!-- var hit = project.hitTest(event.point, { -->
            <!--     fill: true, -->
            <!--     stroke: true, -->
            <!--     segments: true, -->
            <!--     tolerance: 4 -->
            <!-- }); -->
            <!---->
            <!-- if (hit && hit.item.data.isPiece) { -->
            <!--     console.log('chess piece'); -->
            <!-- } -->
        };

        var turn = 'w';
        var piece_selected = null;
        tool.onMouseDown = function(event) {
            var p = event.point; // real canvas coords
            if (p.x >= origin.x && p.y >= origin.y && p.x < 8*s + origin.x && p.y < 8*s + origin.y) {
                var file = Math.floor((p.x - origin.x) / s); // 0–7
                var rank = Math.floor((p.y - origin.y) / s); // 0–7
                // this click event is to put the piece down on a new square (ie move piece)
                if (piece_selected) {
                    // about to move or capture
                    var piece = pieces[8 * rank + file];
                    if (piece) {
                        if (piece.color != piece_selected.color) {
                            // capture
                            for (var i = 0; i < 64; i++) {
                                if (pieces[i] && (pieces[i].pid == piece_selected.pid)) {
                                    pieces = capture_piece(pieces, i, 8 * rank + file);
                                    break;
                                }
                            }
                        };
                    } else {
                        for (var i = 0; i < 64; i++) {
                            if (pieces[i] && (pieces[i].pid == piece_selected.pid)) {
                                pieces = move_piece(pieces, i, 8 * rank + file);
                                break;
                            }
                        }
                    };
                    var pos = new Point(s*file + s/2, s*rank + s/2);
                    piece_selected.icon.position = pos + origin;
                    piece_selected = null;
                    highlight.visible = false;
                    return;
                } else {
                    // this click is to select a piece
                    // FIXME: this should remove the highlight and not move the piece if clicked on
                    // the empty square that is not a move or attack
                    var piece = pieces[8 * rank + file];
                    if (piece && piece.color == turn) {
                        console.log(piece.color + " " + piece.kind);
                        move_highlight(rank, file);
                        piece_selected = piece;
                        draw_pieces(pieces, s, origin);
                    } else {
                        highlight.visible = false;
                    };
                }
            };
        };

        function boardToFEN_fromClient(pieces) {
            var pieceToFen = {
                "pawn":   "p",
                "knight": "n",
                "bishop": "b",
                "rook":   "r",
                "queen":  "q",
                "king":   "k"
            };

            var fen = "";

            for (var rank = 7; rank >= 0; rank--) {
                var empty = 0;

                for (var file = 0; file < 8; file++) {
                    var sq = rank * 8 + file;
                    var piece = pieces[sq];

                    if (!piece) {
                        empty++;
                        continue;
                    }

                    if (empty > 0) {
                        fen += empty.toString();
                        empty = 0;
                    }

                    var code = pieceToFen[piece.kind];
                    if (piece.color === "w") code = code.toUpperCase();
                    fen += code;
                }

                if (empty > 0) fen += empty.toString();

                if (rank > 0) fen += "/";
            }

            // default fields
            var activeColor = "w"; // or track your `turn` variable
            var castling = "KQkq";
            var enpassant = "-";
            var halfmove = "0";
            var fullmove = "1";

            return fen + " " + activeColor + " " + castling + " " + enpassant + " " + halfmove + " " + fullmove;
        }


        // websocket connection to the chess engine
        var ws = new WebSocket("ws://localhost:8080")
        ws.addEventListener("open", function(event) {
          ws.send("m w p e2e4");
        });
        // Listen for messages
        ws.addEventListener("message", function(event) {
          console.log("Message from server ", event.data);
        });

        ws.addEventListener("message", function(event) {
            // TODO: only do this for an appropriate msg type
            console.log("Server FEN:", event.data);

            var clientFen = boardToFEN_fromClient(pieces);

            console.log("Client FEN:", clientFen);

            if (clientFen === event.data.trim()) {
                console.log("FEN MATCH");
            } else {
                console.log("FEN MISMATCH");
            }
        });


    </script>

</head>
<body>
	<canvas id="myCanvas" width=1000 height=1000></canvas>
</body>
</html>
