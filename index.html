<!DOCTYPE html>
<html>
<head>
    <!-- Load the Paper.js library -->
    <script type="text/javascript" src="./node_modules/paper/dist/paper-full.js"></script>
    <!-- Define inlined PaperScript associate it with myCanvas -->
    <script type="text/paperscript" canvas="myCanvas">
        function Piece(kind, color, pid) {
            var img_path = './imgs/' + kind + '-' + color + '.svg';
            return { kind: kind, color: color, img_path: img_path, icon: null, pid: pid };
        }

        function draw_board(l, s, from)
        {
            // board base
            <!-- var to = new Point(l, l) + from; -->
            var path = new Path.Rectangle(from, l);
            path.strokeColor = 'black';
            // squares
            for (var i = 0; i < 8; i++) {
                for (var j = 0; j < 8; j++) {
                    var s_from = new Point(s*i, s*j) + from;
                    var s_to = s_from + [s, s];
                    var sq = new Path.Rectangle(s_from, s_to);
                    sq.strokeColor = 'black';
                    // make checker pattern
                    sq.fillColor = ((i + j) % 2 == 1) ? '#cd8500' : '#ffd39b';
                };
            };
        };

        /** ///////////////////////////////////////////////////////////////////////////////////////
         * Piece class
         */ ///////////////////////////////////////////////////////////////////////////////////////
        function PieceClass(kind, color)
        {
            // Using var for variable declarations
            var self = this;
            
            self.kind = kind;
            self.color = color;
            self.idx = null;
            self.icon = null;
            self.img_path = './imgs/' + self.kind + '-' + self.color + '.svg';
        }

        PieceClass.prototype.set_idx = function(idx)
        {
            this.idx = idx;
        };

        PieceClass.prototype.init_icon = function(pos, from)
        {
            if (!this.icon) {
                // FIX: Using .bind(this) to correctly set the 'this' context inside the async callback
                // This is the ES5 way to handle asynchronous 'this' binding.
                paper.project.importSVG(this.img_path, function(item) {
                    item.position = pos + from;
                    item.scale(0.25);
                    this.icon = item;
                }.bind(this));
            }
        };

        PieceClass.prototype.move_icon = function(pos, from)
        {
            if (this.icon) {
                var new_pos = pos + from
                if (this.icon.position != new_pos) {
                    this.icon.position = new_pos;
                }
            } else {
                this.init_icon(pos, from);
            }
        };

        PieceClass.prototype.remove_icon = function()
        {
            if (this.icon) {
                this.icon.remove();
            } 
        };
        /** ///////////////////////////////////////////////////////////////////////////////////////
         */ ///////////////////////////////////////////////////////////////////////////////////////


        // I got FEN (aka new array of Pieces), i got old array of Pieces
        // for each item in the old array check if
        //     i)   new array has one just like that (kind, color, idx all the same)
        //     ii)  new array has one but in a different idx
        //     iii) new array doesnt have it
        // could start with comparing the lengths of the new and old arrays:
        //     i)   if the len is the same -> silent move or castling or promotion
        //     ii)  if len(old) > len(new) -> piece taken or en-passante
        //     iii) if len(old) < len(new) -> error
        function fen_to_pieces(fen)
        {
            var pieces = [];
            var i = 0;
            var fenPositions = fen.split(' ')[0];
            var fenRanks = fenPositions.split('/'); // 8 ranks
            var pieceId = 0;
            for (var fenRank = 0; fenRank < 8; fenRank++) {
                var file = 0;
                for (var j = 0; j < fenRanks[fenRank].length; j++) {
                    var char = fenRanks[fenRank][j];
                    // digit = empty squares
                    if (char >= '1' && char <= '8') {
                        file += parseInt(char, 10);
                    } else {
                        var color = char === char.toUpperCase() ? 'w' : 'b';
                        var kind = char.toLowerCase();
                        // convert FEN rank (8→1) to LERF index
                        var rank = 7 - fenRank;
                        var idx = rank * 8 + file;
                        <!-- pieces[idx] = new Piece(kind, color, pieceId++); -->
                        var new_piece = new PieceClass(kind, color);
                        new_piece.set_idx(idx);
                        pieces.push(new_piece);
                        i++;
                        file++;
                    }
                }
            }
            return pieces;
        }

        function draw_pieces(pieces, s, from)
        {
            for (var i = 0; i < pieces.length; i++) {
                if (pieces[i]) {
                    (function(p) {
                        var idx = p.idx;
                        var rank = Math.floor(idx / 8);
                        var file = idx % 8;
                        var pos = new Point(s*file + s/2, s*rank + s/2);
                        p.move_icon(pos, from);
                    })(pieces[i]);
                };
            };
        };

        <!-- function clear_all_icons(pieces) { -->
        <!--     for (var i = 0; i < 64; i++) { -->
        <!--         if (pieces[i]) { -->
        <!--             pieces[i].icon.remove(); -->
        <!--         }; -->
        <!--     }; -->
        <!-- }; -->

        // Constants and globals
        var origin = new Point(20, 20);
        var l = 256;
        var s = l / 8.0;
        draw_board(l, s, origin);
        <!-- clear_all_icons(pieces); -->
        pieces = fen_to_pieces("rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1")
        draw_pieces(pieces, s, origin);

        var highlight = new Path.Rectangle({
            point: [origin.x, origin.y],
            size: [s, s],
            strokeColor: 'green',
            strokeWidth: 3,
            fillColor: null,
            visible: false   // start hidden
        });

        function move_highlight(rank, file) {
            var s_from = new Point(s * file, s * rank) + origin;
            highlight.bounds = new Rectangle(s_from, new Size(s, s));
            highlight.visible = true;
        };

        var debugText = new PointText({
            point: [300, 50],
            fillColor: 'black',
            fontSize: 14,
            strokeBounds: new Path.Rectangle({
                point: [290, 30],
                size: [200, 70],
                strokeColor: 'black',
                fillColor: null,
            })
        });

        var tool = new Tool();

        tool.onMouseMove = function(event)
        {
            var p = event.point; // real canvas coords

            // Check if inside board
            if (p.x >= origin.x && p.y >= origin.y && p.x < 8*s + origin.x && p.y < 8*s + origin.y) {

                var file = Math.floor((p.x - origin.x) / s); // 0–7
                var rank = Math.floor((p.y - origin.y) / s); // 0–7
                var fileChar = String.fromCharCode('a'.charCodeAt(0) + file);
                var rankChar = 8 - rank;

                debugText.content = "mouse: " + p + "\n" + "square: " + fileChar + rankChar;
                
                var piece = null;
                var idx = 8 * rank + file;
                for (var i = 0; i < pieces.length; i++) {
                    if (pieces[i].idx == idx) {piece = pieces[i];}
                }
                var piece_txt = "\n" + "piece: " + (piece ? piece.color + " " + piece.kind : "");
                debugText.content += piece_txt;

            } else {
                debugText.content = "mouse: " + p;
            }
        };


        // websocket connection to the chess engine
        var ws = new WebSocket("ws://localhost:8080")
        // Listen for messages
        ws.addEventListener("message", function(event) {
            console.log("Message from server ", event.data);
            // TODO: only do this for an appropriate msg type
            var serverFEN = event.data.trim();
            // TODO: when there are msgs that are not just FEN need to parse the type
            <!-- clear_all_icons(pieces); -->
            pieces = fen_to_pieces(serverFEN);
            draw_pieces(pieces, s, origin);
        });

        function idx_to_algebraic(idx) {
            var rank = Math.floor(idx / 8) + 1;
            var file = idx % 8;
            return String.fromCharCode(97 + file) + rank;
        };
        
        function move_piece(pieces, idx_from, idx_to) {
            if (idx_from == idx_to) {
                return;
            }
            // TODO use .filter of the array
            var piece = null;
            for (var i = 0; i < pieces.length; i++) {
                if (pieces[i].idx == idx_from) {piece = pieces[i];}
            }
            console.assert(piece);
            var algebraic_from = idx_to_algebraic(idx_from);
            var algebraic_to   = idx_to_algebraic(idx_to);
            var msg = "m " + piece.color + " " + piece.kind + " " + algebraic_from + algebraic_to;
            ws.send(msg);
            return;
        };

        <!-- function capture_piece(pieces, idx_from, idx_to) { -->
        <!--     if (idx_from == idx_to) { -->
        <!--         return pieces; -->
        <!--     } -->
        <!--     // FIXME: record in the list of captured pieces -->
        <!--     var captured_piece = pieces[idx_to]; -->
        <!--     captured_piece.icon.remove(); -->
        <!--     pieces[idx_to] = null; -->
        <!--     return move_piece(pieces, idx_from, idx_to); -->
        <!-- }; -->

        var turn = 'w';
        var piece_selected = null;
        tool.onMouseDown = function(event) {
            var p = event.point; // real canvas coords
            if (p.x >= origin.x && p.y >= origin.y && p.x < 8*s + origin.x && p.y < 8*s + origin.y) {
                var file = Math.floor((p.x - origin.x) / s); // 0–7
                var rank = Math.floor((p.y - origin.y) / s); // 0–7
                // this click event is to put the piece down on a new square (ie move piece)
                if (piece_selected) {
                    // about to move or capture
                    var piece = null;
                    var idx = 8 * rank + file;
                    for (var i = 0; i < pieces.length; i++) {
                        if (pieces[i].idx == idx) {piece = pieces[i];}
                    }
                    if (piece) {
                        if (piece.color != piece_selected.color) {
                            <!-- // capture -->
                            <!-- for (var i = 0; i < 64; i++) { -->
                            <!--     if (pieces[i] && (pieces[i].pid == piece_selected.pid)) { -->
                            <!--         pieces = capture_piece(pieces, i, 8 * rank + file); -->
                            <!--         break; -->
                            <!--     } -->
                            <!-- } -->
                        };
                    } else {
                        // FIXME: surely there is a better way since we already have access to
                        // piece_selected
                        move_piece(pieces, piece_selected.idx, 8 * rank + file);
                    };
                    var pos = new Point(s*file + s/2, s*rank + s/2);
                    <!-- piece_selected.icon.position = pos + origin; -->
                    piece_selected.move_icon(pos, origin);
                    piece_selected = null;
                    highlight.visible = false;
                    return;
                } else {
                    // this click is to select a piece
                    // FIXME: this should remove the highlight and not move the piece if clicked on
                    // the empty square that is not a move or attack
                    var piece = null;
                    var idx = 8 * rank + file;
                    for (var i = 0; i < pieces.length; i++) {
                        if (pieces[i].idx == idx) {piece = pieces[i];}
                    }
                    if (piece && piece.color == turn) {
                        console.log(piece.color + " " + piece.kind);
                        move_highlight(rank, file);
                        piece_selected = piece;
                        draw_pieces(pieces, s, origin);
                    } else {
                        highlight.visible = false;
                    };
                }
            };
        };


    </script>

</head>
<body>
	<canvas id="myCanvas" width=1000 height=1000></canvas>
</body>
</html>
